// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package database

import (
	"database/sql"
	"fmt"
	"time"

	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewLogin returns a new instance of Login.
func NewLogin() (record *Login) {
	return new(Login)
}

// GetID returns the primary key of the model.
func (r *Login) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.AccountID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Login) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "account_id":
		return (*kallax.ULID)(&r.AccountID), nil
	case "source_ip":
		return &r.SourceIP, nil
	case "date_created":
		return &r.DateCreated, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Login: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Login) Value(col string) (interface{}, error) {
	switch col {
	case "account_id":
		return r.AccountID, nil
	case "source_ip":
		return r.SourceIP, nil
	case "date_created":
		return r.DateCreated, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Login: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Login) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Login has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Login) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Login has no relationships")
}

// LoginStore is the entity to access the records of the type Login
// in the database.
type LoginStore struct {
	*kallax.Store
}

// NewLoginStore creates a new instance of LoginStore
// using a SQL database.
func NewLoginStore(db *sql.DB) *LoginStore {
	return &LoginStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *LoginStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *LoginStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *LoginStore) Debug() *LoginStore {
	return &LoginStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *LoginStore) DebugWith(logger kallax.LoggerFunc) *LoginStore {
	return &LoginStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *LoginStore) DisableCacher() *LoginStore {
	return &LoginStore{s.Store.DisableCacher()}
}

// Insert inserts a Login in the database. A non-persisted object is
// required for this operation.
func (s *LoginStore) Insert(record *Login) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.DateCreated = record.DateCreated.Truncate(time.Microsecond)

	return s.Store.Insert(Schema.Login.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *LoginStore) Update(record *Login, cols ...kallax.SchemaField) (updated int64, err error) {
	record.DateCreated = record.DateCreated.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Login.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *LoginStore) Save(record *Login) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *LoginStore) Delete(record *Login) error {
	return s.Store.Delete(Schema.Login.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *LoginStore) Find(q *LoginQuery) (*LoginResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewLoginResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *LoginStore) MustFind(q *LoginQuery) *LoginResultSet {
	return NewLoginResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *LoginStore) Count(q *LoginQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *LoginStore) MustCount(q *LoginQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *LoginStore) FindOne(q *LoginQuery) (*Login, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *LoginStore) FindAll(q *LoginQuery) ([]*Login, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *LoginStore) MustFindOne(q *LoginQuery) *Login {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Login with the data in the database and
// makes it writable.
func (s *LoginStore) Reload(record *Login) error {
	return s.Store.Reload(Schema.Login.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *LoginStore) Transaction(callback func(*LoginStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&LoginStore{store})
	})
}

// LoginQuery is the object used to create queries for the Login
// entity.
type LoginQuery struct {
	*kallax.BaseQuery
}

// NewLoginQuery returns a new instance of LoginQuery.
func NewLoginQuery() *LoginQuery {
	return &LoginQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Login.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *LoginQuery) Select(columns ...kallax.SchemaField) *LoginQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *LoginQuery) SelectNot(columns ...kallax.SchemaField) *LoginQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *LoginQuery) Copy() *LoginQuery {
	return &LoginQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *LoginQuery) Order(cols ...kallax.ColumnOrder) *LoginQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *LoginQuery) BatchSize(size uint64) *LoginQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *LoginQuery) Limit(n uint64) *LoginQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *LoginQuery) Offset(n uint64) *LoginQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *LoginQuery) Where(cond kallax.Condition) *LoginQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByAccountID adds a new filter to the query that will require that
// the AccountID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *LoginQuery) FindByAccountID(v ...kallax.ULID) *LoginQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Login.AccountID, values...))
}

// FindBySourceIP adds a new filter to the query that will require that
// the SourceIP property is equal to the passed value.
func (q *LoginQuery) FindBySourceIP(v string) *LoginQuery {
	return q.Where(kallax.Eq(Schema.Login.SourceIP, v))
}

// FindByDateCreated adds a new filter to the query that will require that
// the DateCreated property is equal to the passed value.
func (q *LoginQuery) FindByDateCreated(cond kallax.ScalarCond, v time.Time) *LoginQuery {
	return q.Where(cond(Schema.Login.DateCreated, v))
}

// LoginResultSet is the set of results returned by a query to the
// database.
type LoginResultSet struct {
	ResultSet kallax.ResultSet
	last      *Login
	lastErr   error
}

// NewLoginResultSet creates a new result set for rows of the type
// Login.
func NewLoginResultSet(rs kallax.ResultSet) *LoginResultSet {
	return &LoginResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *LoginResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Login.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Login)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Login")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *LoginResultSet) Get() (*Login, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *LoginResultSet) ForEach(fn func(*Login) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *LoginResultSet) All() ([]*Login, error) {
	var result []*Login
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *LoginResultSet) One() (*Login, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *LoginResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *LoginResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewRegistration returns a new instance of Registration.
func NewRegistration() (record *Registration) {
	return new(Registration)
}

// GetID returns the primary key of the model.
func (r *Registration) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Registration) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.ULID)(&r.ID), nil
	case "source_ip":
		return &r.SourceIP, nil
	case "date_registered":
		return &r.DateRegistered, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Registration: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Registration) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "source_ip":
		return r.SourceIP, nil
	case "date_registered":
		return r.DateRegistered, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Registration: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Registration) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Registration has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Registration) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Registration has no relationships")
}

// RegistrationStore is the entity to access the records of the type Registration
// in the database.
type RegistrationStore struct {
	*kallax.Store
}

// NewRegistrationStore creates a new instance of RegistrationStore
// using a SQL database.
func NewRegistrationStore(db *sql.DB) *RegistrationStore {
	return &RegistrationStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *RegistrationStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *RegistrationStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *RegistrationStore) Debug() *RegistrationStore {
	return &RegistrationStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *RegistrationStore) DebugWith(logger kallax.LoggerFunc) *RegistrationStore {
	return &RegistrationStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *RegistrationStore) DisableCacher() *RegistrationStore {
	return &RegistrationStore{s.Store.DisableCacher()}
}

// Insert inserts a Registration in the database. A non-persisted object is
// required for this operation.
func (s *RegistrationStore) Insert(record *Registration) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.DateRegistered = record.DateRegistered.Truncate(time.Microsecond)

	return s.Store.Insert(Schema.Registration.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *RegistrationStore) Update(record *Registration, cols ...kallax.SchemaField) (updated int64, err error) {
	record.DateRegistered = record.DateRegistered.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Registration.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *RegistrationStore) Save(record *Registration) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *RegistrationStore) Delete(record *Registration) error {
	return s.Store.Delete(Schema.Registration.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *RegistrationStore) Find(q *RegistrationQuery) (*RegistrationResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewRegistrationResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *RegistrationStore) MustFind(q *RegistrationQuery) *RegistrationResultSet {
	return NewRegistrationResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *RegistrationStore) Count(q *RegistrationQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *RegistrationStore) MustCount(q *RegistrationQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *RegistrationStore) FindOne(q *RegistrationQuery) (*Registration, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *RegistrationStore) FindAll(q *RegistrationQuery) ([]*Registration, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *RegistrationStore) MustFindOne(q *RegistrationQuery) *Registration {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Registration with the data in the database and
// makes it writable.
func (s *RegistrationStore) Reload(record *Registration) error {
	return s.Store.Reload(Schema.Registration.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *RegistrationStore) Transaction(callback func(*RegistrationStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&RegistrationStore{store})
	})
}

// RegistrationQuery is the object used to create queries for the Registration
// entity.
type RegistrationQuery struct {
	*kallax.BaseQuery
}

// NewRegistrationQuery returns a new instance of RegistrationQuery.
func NewRegistrationQuery() *RegistrationQuery {
	return &RegistrationQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Registration.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *RegistrationQuery) Select(columns ...kallax.SchemaField) *RegistrationQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *RegistrationQuery) SelectNot(columns ...kallax.SchemaField) *RegistrationQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *RegistrationQuery) Copy() *RegistrationQuery {
	return &RegistrationQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *RegistrationQuery) Order(cols ...kallax.ColumnOrder) *RegistrationQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *RegistrationQuery) BatchSize(size uint64) *RegistrationQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *RegistrationQuery) Limit(n uint64) *RegistrationQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *RegistrationQuery) Offset(n uint64) *RegistrationQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *RegistrationQuery) Where(cond kallax.Condition) *RegistrationQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *RegistrationQuery) FindByID(v ...kallax.ULID) *RegistrationQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Registration.ID, values...))
}

// FindBySourceIP adds a new filter to the query that will require that
// the SourceIP property is equal to the passed value.
func (q *RegistrationQuery) FindBySourceIP(v string) *RegistrationQuery {
	return q.Where(kallax.Eq(Schema.Registration.SourceIP, v))
}

// FindByDateRegistered adds a new filter to the query that will require that
// the DateRegistered property is equal to the passed value.
func (q *RegistrationQuery) FindByDateRegistered(cond kallax.ScalarCond, v time.Time) *RegistrationQuery {
	return q.Where(cond(Schema.Registration.DateRegistered, v))
}

// RegistrationResultSet is the set of results returned by a query to the
// database.
type RegistrationResultSet struct {
	ResultSet kallax.ResultSet
	last      *Registration
	lastErr   error
}

// NewRegistrationResultSet creates a new result set for rows of the type
// Registration.
func NewRegistrationResultSet(rs kallax.ResultSet) *RegistrationResultSet {
	return &RegistrationResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *RegistrationResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Registration.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Registration)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Registration")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *RegistrationResultSet) Get() (*Registration, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *RegistrationResultSet) ForEach(fn func(*Registration) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *RegistrationResultSet) All() ([]*Registration, error) {
	var result []*Registration
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *RegistrationResultSet) One() (*Registration, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *RegistrationResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *RegistrationResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Login        *schemaLogin
	Registration *schemaRegistration
}

type schemaLogin struct {
	*kallax.BaseSchema
	AccountID   kallax.SchemaField
	SourceIP    kallax.SchemaField
	DateCreated kallax.SchemaField
}

type schemaRegistration struct {
	*kallax.BaseSchema
	ID             kallax.SchemaField
	SourceIP       kallax.SchemaField
	DateRegistered kallax.SchemaField
}

var Schema = &schema{
	Login: &schemaLogin{
		BaseSchema: kallax.NewBaseSchema(
			"login",
			"__login",
			kallax.NewSchemaField("account_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Login)
			},
			false,
			kallax.NewSchemaField("account_id"),
			kallax.NewSchemaField("source_ip"),
			kallax.NewSchemaField("date_created"),
		),
		AccountID:   kallax.NewSchemaField("account_id"),
		SourceIP:    kallax.NewSchemaField("source_ip"),
		DateCreated: kallax.NewSchemaField("date_created"),
	},
	Registration: &schemaRegistration{
		BaseSchema: kallax.NewBaseSchema(
			"registration",
			"__registration",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Registration)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("source_ip"),
			kallax.NewSchemaField("date_registered"),
		),
		ID:             kallax.NewSchemaField("id"),
		SourceIP:       kallax.NewSchemaField("source_ip"),
		DateRegistered: kallax.NewSchemaField("date_registered"),
	},
}
